<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
  "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Vim Control Sequence Example</title>
<meta http-equiv="Content-Style-Type" content="text/css">
<link rel="stylesheet" href="../../style.css" type="text/css">
</head>
<body>

<h1>Vim Control Sequence Examples</h1>
<p>
When a user uses the control sequence, the remote host can control the Tera Term behavior.
The Vim procedure for using the control sequence is described below.
</p>

<h2><a name="CursorStyle">Changing cursor shape on entering and leaving into insert mode</a></h2>
<p>
Tera Term can support below control sequence changing the cursor shape.
</p>

<table border="1">
  <tr> <th>Abbreviation</th> <th>Sequence</th> <th>Function</th> </tr>

  <tr> <td rowspan="2">DECTCEM</td>
       <td>ESC [ ? 25 h</td> <td>Makes the cursor visible</td> </tr>
  <tr> <td>ESC [ ? 25 l</td> <td>Makes the cursor invisible</td> </tr>

  <tr> <td rowspan="7">DECSCUSR</td>
       <td>ESC SP 0 q</td> <td>Blink Block</td> </tr>
  <tr> <td>ESC SP 1 q</td> <td>Blink Block</td> </tr>
  <tr> <td>ESC SP 2 q</td> <td>Steady Block</td> </tr>
  <tr> <td>ESC SP 3 q</td> <td>Blink Underline</td> </tr>
  <tr> <td>ESC SP 4 q</td> <td>Steady Underline</td> </tr>
  <tr> <td>ESC SP 5 q</td> <td>Blink Vertical line</td> </tr>
  <tr> <td>ESC SP 6 q</td> <td>Steady Vertical line</td> </tr>

  <tr> <td rowspan="2">WYSTCURM</td>
       <td>ESC [ 33 h</td> <td>Steady Wyse Cursor</td> </tr>
  <tr> <td>ESC [ 33 l</td> <td>Blink Wyse Cursor</td> </tr>

  <tr> <td rowspan="2">WYULCURM</td>
       <td>ESC [ 34 h</td> <td>Steady Wyse underline cursor</td> </tr>
  <tr> <td>ESC [ 34 l</td> <td>Steady Wyse block cursor</td> </tr>

  <tr> <td rowspan="2"> (AT&amp;T 610) </td>
       <td>ESC [ ? 12 l</td> <td>Steady Cursor</td> </tr>
  <tr> <td>ESC [ ? 12 h</td> <td>Blink Cursor</td> </tr>
</table>

<p>
The vim cursor can be changed in the insert mode to output above control sequences when a user enters(t_SI) and leaves(t_EI). <br>
For example, when below contents is added in the .vimrc file, the cursor style is underline and blinking in the insert mode. Next, the cursor style is block and blinking outside the insert mode.
</p>

<pre class="macro-example">
let &amp;t_SI .= "\e[3 q"
let &amp;t_EI .= "\e[1 q"
</pre>

<p>NOTICE: If a user uses the control sequence except the DECTCEM, turn on the Cursor control sequence of the Additional Settings dialog(The default value is off).</p>


<h2><a name="Bracketed">Auto indent can be disabled on pasting from clipboard</a></h2>
<p>
Basically, the host application can not recognize the difference between the user input and pasting from clipboard.
However, when a user uses the Bracketed Paste Mode as the xterm extension, the application can recognize its difference and a user can change the behavior of pasting from clipboard.
</p>

<p>
The vim configuration is described below. The following will use xterm's bracketed paste mode to make pasting automatically enable paste mode and insert mode. Also works fine in ~/.vimrc file.
</p>

<pre class="macro-example">
if &amp;term =~ "xterm"
    let &amp;t_ti .= "\e[?2004h"
    let &amp;t_te .= "\e[?2004l"
    let &amp;pastetoggle = "\e[201~"

    function XTermPasteBegin(ret)
        set paste
        return a:ret
    endfunction

    noremap &lt;special&gt; &lt;expr&gt; &lt;Esc&gt;[200~ XTermPasteBegin("0i")
    inoremap &lt;special&gt; &lt;expr&gt; &lt;Esc&gt;[200~ XTermPasteBegin("")
    cnoremap &lt;special&gt; &lt;Esc&gt;[200~ &lt;nop&gt;
    cnoremap &lt;special&gt; &lt;Esc&gt;[201~ &lt;nop&gt;
endif
</pre>

<!-- p>
上記の設定ではノーマルモードで貼り付けを行うと挿入モードに切り替わって貼り付けが行われますが、これを行わずに挿入モードの時のみ有効にする場合は以下の設定を使用して下さい。<br>
後述の<a href="#withScreen">GNU Screenとの併用時の注意点</a>にある設定を行う場合はこちらの方が都合がいいでしょう。
</p -->

<pre class="macro-example">
if &amp;term =~ "xterm"
    let &amp;t_SI .= "\e[?2004h"
    let &amp;t_EI .= "\e[?2004l"
    let &amp;pastetoggle = "\e[201~"

    function XTermPasteBegin(ret)
        set paste
        return a:ret
    endfunction

    inoremap &lt;special&gt; &lt;expr&gt; &lt;Esc&gt;[200~ XTermPasteBegin("")
endif
</pre>

<h4>About Bracketed Paste mode</h4>
<p>
The bracketed paste mode is the xterm extension feature. When this feature is enabled, the pasted text is bracketed with control sequences so that the program can differentiate the pasted text from typed-in text.<br>
The program will receive: ESC [ 200 ~, followed by the pasted text, followed by ESC [ 201 ~.
</p>


<h2><a name="IMEcontrol">Controlling IME</a></h2>
<p>
Tera Term can support the original sequence to control the IME behavior.
For example, A user can switch the IME status of enabling and disabling to use this control sequence.
</p>

<p>
When below contents is be added in the .vimrc file, the IME status is off after the insert mode exiting. Next, the IME status is on after the insert mode enabling.
</p>

<pre class="macro-example">
let &t_SI .= "\e[&lt;r"
let &t_EI .= "\e[&lt;s\e[&lt;0t"
let &t_te .= "\e[&lt;0t\e[&lt;s"

set timeoutlen=100
</pre>

<p>
When the timeoutlen of the vim is enabled, the vim will wait until either the complete mapping or key sequence has been received. In other words, the timeoutlen is used to describe the time from IME on to off after the ESC key is pressed in the insert mode. <br>
If the timeoutlen is the small value, a trouble may occur that the cursor and function key do not work well. <br>
As an alternative, please use the <a href="#AppESC">Delete wait time after ESC key is pushed in insert mode</a>.
</p>


<h2><a name="AppESC">Delete wait time after ESC key is pushed in insert mode</a></h2>
<p>
When the ESC key is pressed, Tera Term, xterm and other terminal emulator send the ESC(0x1b) key code. Also, when the cursor key and the function key is pushed, Tera Term sends the ESC key code.
Therefore, the host application can not recognize whether the ESC key is pressed. <br>
So, the vim waits for one second when the ESC key code is received to recognize what key is pressed.
As a result, when a user presses the ESC key, the time for the insert mode exiting will be late for 1 second.
This behavior can not be affected by enabling <a href="#CursorStyle">Changing cursor shape on entering and leaving into insert mode</a> and <a href="#IMEcontrol">Controlling IME</a>.
</p>

<p>
Please use the Application Wheel Mode to resolve this problem.
When below contents is added in the .vimrc file, the insert mode is quickly exited after the ESC key is pressed.
</p>

<pre class="macro-example">
let &t_SI .= "\e[?7727h"
let &t_EI .= "\e[?7727l"
inoremap &lt;special&gt; &lt;Esc&gt;O[ &lt;Esc&gt;
</pre>


<!--
<h2><a name="withScreen">GNU Screenとの併用時の注意点</a></h2>
<p>
GNU Screenを使用している場合、screen内部で動かしているアプリケーションが制御シーケンスを送っても、そのシーケンスにscreenが対応していない場合はTera Term側へ送らずに捨ててしまい期待通りに動きません。その場合、
</p>

<pre class="macro-example">
if &amp;term == "screen"
    let &amp;t_SI .= "\eP\e[3 q\e\\"
    let &amp;t_EI .= "\eP\e[1 q\e\\"
else
    let &amp;t_SI .= "\e[3 q"
    let &amp;t_EI .= "\e[1 q"
endif
</pre>

<p>
というように、端末タイプが screen の時は t_SI, t_EI, t_ti, t_te に設定するシーケンスを "\eP" と "\e\\" で挟むとTera Termに制御シーケンスが届くようになります。<br>
ただし、この方法を使って制御シーケンスがscreenを抜けるようにしても送ったシーケンスの状態はscreenの管理外になるので、screenのウィンドウを切り替えた時等に期待通りに動かない場合がありますので注意してください。
</p>
-->

</body>
</html>
