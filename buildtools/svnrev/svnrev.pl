use strict;
use warnings;
use utf8;
use Getopt::Long 'GetOptions';
use POSIX 'strftime';

binmode STDOUT, ':encoding(utf8)';

my $tt_version_major = 0;
my $tt_version_minor = 0;
my $tt_version_patch = 0;
my $tt_version_substr = "";
my $tt_version_h = "../../teraterm/common/tt-version.h";
my $version;
my $svn = "svn";
my $git = "git";
my $out_header = "svnversion.h";
my $out_bat = "sourcetree_info.bat";
my $out_cmake = "";
my $out_json = "";
my $source_root = "../..";
my $build_year = strftime "%Y", localtime;
my $date = $build_year . strftime "%m%d", localtime;
my $time = strftime "%H%M%S", localtime;
my $username = $ENV{'USER'} || 'noname';
my $verbose = 0;
my $script_name = $0;
my $header = "This file was generated by buildtools/svnrev/svnrev.pl";
my $overwrite = 0;
my %svninfo = (
	name => '',
	release => 0,
	Revision => '',
	vcs => '',
	);
my $out_isl = "";
my $architecture = "Win32";		# VS(Win32 / x64 / ARM64) / MinGW(i686 / x86_64)

sub read_toolinfo {
	my $info = "toolinfo.txt";
	if (!-f $info) {
		return;
	}
	open(my $FD, "<:utf8:crlf", $info);
	while (my $l = <$FD>) {
		chomp $l;
		$l =~ s/^\x{FEFF}//;	# remove BOM
		if ($l =~ /^#/) {
			next;
		}
		if ($l =~ /^svn=\s*(.*)$/) {
			$svn = $1;
		}
		if ($l =~ /^git=\s*(.*)$/) {
			$git = $1;
		}
	}
	close($FD);
}

sub search_svn {
	my @test_list = (
		"C:/Program Files (x86)/Subversion/bin/svn.exe",
		"C:/Program Files/Subversion/bin/svn.exe",
		"C:/Program Files/TortoiseSVN/bin/svn.exe",
		"C:/cygwin64/bin/svn.exe",
		"C:/cygwin/bin/svn.exe",
		"/usr/bin/svn.exe"	# msys, cygwin
		);
	for (my $i = 0; $i < @test_list; $i++) {
		my $test = $test_list[$i];
		if (-e $test) {
			$svn = $test;
			return;
		}
	}
}

sub search_git {
	my @test_list = (
		"C:/Program Files/Git/bin/git.exe",
		"C:/cygwin64/bin/git.exe",
		"C:/cygwin/bin/git.exe",
		"/usr/bin/git.exe"	# msys, cygwin
		);
	for (my $i = 0; $i < @test_list; $i++) {
		my $test = $test_list[$i];
		if (-e $test) {
			$git = $test;
			return;
		}
	}
}

sub dump_info {
	my %info = @_;

	print "SVNREVISION $info{'Revision'}\n";
	print "RELEASE $info{'release'}\n";
	print "BRANCH_NAME $info{'name'}\n";
}

sub read_whole_file {
	my $fname = shift;
	open(my $FD, '<', $fname) or die "error open $fname";

	my $text;
	while (<$FD>) {
		if (/DATE/ || /TIME/ || /Date/ || /Time/) {
			; #pass
		} else {
			$text .= $_;
		}
	}
	close $FD;
	return $text;
}

sub compare_file {
	my ($f1, $f2) = @_;
	if (! -f $f1) {
		return 1;
	}
	if (! -f $f2) {
		return 1;
	}
	my $t1 = read_whole_file($f1);
	my $t2 = read_whole_file($f2);
	if ($t1 eq $t2) {
		# return same
		return 0;
	}
	return 1;
}

sub write_info_header {
	my ($out_header, %svninfo) = @_;
	my $revision = $svninfo{'Revision'};
	my $vcs = $svninfo{'vcs'};

	open(my $FD, ">$out_header") or die "error $out_header";
	print $FD "/* $header */\n";
	print $FD "/* #define TT_VERSION_STR \"$version\" check teraterm/common/tt-version.h */\n";
	if ($vcs eq 'git') {
		if ($revision ne '') {
			print $FD "#define GITVERSION \"$revision\"\n";
		} else {
			print $FD "#undef GITVERSION\n";
		}
		print $FD "#undef SVNVERSION\n";
	}
	elsif ($vcs eq 'svn') {
		print $FD "#undef GITVERSION\n";
		if ($revision ne '') {
			print $FD "#define SVNVERSION $revision\n";
		} else {
			print $FD "#undef SVNVERSION\n";
		}
	}
	else {
		print $FD "#undef GITVERSION\n";
		print $FD "#undef SVNVERSION\n";
	}
	if ($svninfo{'release'}) {
		print $FD "#define TERATERM_RELEASE 1\n";
	} else {
		print $FD "#undef TERATERM_RELEASE\n";
	}
	print $FD "#define BRANCH_NAME \"$svninfo{'name'}\"\n";
	print $FD "// use predefine macro _M_IX86 or _M_X64 or _M_ARM64\n";
	print $FD "// #define ARCH \"$architecture\"\n";
	close($FD);
}

sub write_info_bat {
	my ($out_bat, %svninfo) = @_;
	my $revision = $svninfo{'Revision'};
	my $vcs = $svninfo{'vcs'};

	open(my $FD, ">$out_bat") or die "error $out_bat";
	print $FD "\@rem $header\n";
	print $FD "set VERSION=$version\n";
	if ($vcs eq 'git') {
		if ($revision ne '') {
			print $FD "set GITVERSION=$revision\n";
		} else {
			print $FD "set GITVERSION=unknown\n";
		}
		print $FD "set SVNVERSION=unknown\n";
	}
	elsif ($vcs eq 'svn') {
		print $FD "set GITVERSION=unknown\n";
		if ($revision ne '') {
			print $FD "set SVNVERSION=$revision\n";
		} else {
			print $FD "set SVNVERSION=unknown\n";
		}
	}
	else {
		print $FD "set GITVERSION=unknown\n";
		print $FD "set SVNVERSION=unknown\n";
	}
	print $FD "set RELEASE=$svninfo{'release'}\n";
	print $FD "set DATE=$date\n";
	print $FD "set TIME=$time\n";
	print $FD "set ARCHITECTURE=$architecture\n";
	close($FD);
}

sub write_info_cmake {
	my ($out_cmake, %svninfo) = @_;
	my $revision = $svninfo{'Revision'};
	my $vcs = $svninfo{'vcs'};

	open(my $FD, ">$out_cmake") or die "error $out_cmake";
	print $FD "# $header\n";
	print $FD "set(VERSION \"$version\")\n";
	if ($vcs eq 'git') {
		if ($revision ne '') {
			print $FD "set(GITVERSION \"$revision\")\n";
		} else {
			print $FD "#set(GITVERSION \"0000\")\n";
		}
		print $FD "#set(SVNVERSION \"0000\")\n";
	}
	elsif ($vcs eq 'svn') {
		print $FD "#set(GITVERSION \"0000\")\n";
		if ($revision ne '') {
			print $FD "set(SVNVERSION \"$revision\")\n";
		} else {
			print $FD "#set(SVNVERSION \"0000\")\n";
		}
	}
	else {
		print $FD "#set(GITVERSION \"0000\")\n";
		print $FD "#set(SVNVERSION \"0000\")\n";
	}
	print $FD <<"EOS";
set(RELEASE $svninfo{'release'})
set(DATE \"$date\")
set(TIME \"$time\")
#if(\${CMAKE_GENERATOR} MATCHES "Visual Studio")
  set(ARCHITECTURE \"$architecture\")
#endif()
EOS
	close($FD);
}

sub write_info_json {
	my ($out_json, %svninfo) = @_;
	my $revision = $svninfo{'Revision'};
	my $vcs = $svninfo{'vcs'};

	open(my $FD, ">$out_json") or die "error $out_json";
	print $FD "{\n";
	print $FD "  \"VERSION\": \"$version\",\n";
	if ($vcs eq 'git') {
		if ($revision ne '') {
			print $FD "  \"GITVERSION\": \"$revision\",\n";
		} else {
			print $FD "  \"GITVERSION\": \"0000\",\n";
		}
	}
	elsif ($vcs eq 'svn') {
		if ($revision ne '') {
			print $FD "  \"SVNVERSION\": \"$revision\",\n";
		} else {
			print $FD "  \"SVNVERSION\": \"0000\",\n";
		}
	}
	print $FD "  \"RELEASE\": \"$svninfo{'release'}\",\n";
	print $FD "  \"DATE\": \"$date\",\n";
	print $FD "  \"TIME\": \"$time\",\n";
	print $FD "	 \"ARCHITECTURE\":  \"$architecture\"\n";
	print $FD "}\n";
	close($FD);
}

sub write_info_isl {
	my ($out_isl, %svninfo) = @_;
	my $revision = $svninfo{'Revision'};
	my $vcs = $svninfo{'vcs'};
	if ($revision eq '') {
		$revision = "0000";
	}

	my $content = <<"EOS";
\x{FEFF}; $header
#define Version \"$version\"
#define Revision \"$revision\"
#define Release $svninfo{'release'}
#define BuildDate \"$date\"
#define BuildTime \"$time\"
#define UserName \"$username\"
;#define Arch \"$architecture\"
EOS

	open(my $FD, ">:crlf:utf8", $out_isl) or die "error $out_isl";
	print $FD $content;
	close($FD);
}

sub read_tt_version_h()
{
	# ヘッダーファイルがない場合
	if (! -f $tt_version_h) {
		printf("no header\n");
		$tt_version_major = 0;
		$tt_version_minor = 0;
		$tt_version_patch = 0;
		$tt_version_substr = "no_header";
		return;
	}

	open(my $FH, '<', $tt_version_h) or die "error open $tt_version_h";
	while (<$FH>) {
		if (/^\s*#define\s+TT_VERSION_MAJOR\s+(\d+)/) {
			$tt_version_major = $1;
		}
		elsif (/^\s*#define\s+TT_VERSION_MINOR\s+(\d+)/) {
			$tt_version_minor = $1;
		}
		elsif (/^\s*#define\s+TT_VERSION_PATCH\s+(\d+)/) {
			$tt_version_patch = $1;
		}
		elsif (/^\s*#define\s+TT_VERSION_SUBSTR\s+\"(.+)\"/) {
			$tt_version_substr = $1;
		}
	}
	close $FH;
}

&read_tt_version_h();
&search_svn();
&search_git();
&read_toolinfo();

GetOptions(
	'root=s' => \$source_root,
	'svn=s' => \$svn,
	'git=s' => \$git,
	'header=s' => \$out_header,
	'bat=s' => \$out_bat,
	'cmake=s' => \$out_cmake,
	'json=s' => \$out_json,
	'verbose' => \$verbose,
	'overwrite' => \$overwrite,
	'isl=s' => \$out_isl,
	'architecture=s' => \$architecture
);

$git =~ s/"//g;
$git =~ s/\\/\//g;
$svn =~ s/"//g;
$svn =~ s/\\/\//g;

if ($tt_version_substr eq "") {
	$version = "$tt_version_major.$tt_version_minor.$tt_version_patch";
} else {
	$version = "$tt_version_major.$tt_version_minor.$tt_version_patch-$tt_version_substr";
}

if ($verbose != 0) {
	print <<"EOS"
root=$source_root
tt_version_major=$tt_version_major
tt_version_minor=$tt_version_minor
tt_version_patch=$tt_version_patch
tt_version_substr=$tt_version_substr
svn=\"$svn\"
git=\"$git\"
header=\"$out_header\"
bat=\"$out_bat\"
cmake=\"$out_cmake\"
json=\"$out_json\"
overwrite $overwrite
architecture=\"$architecture\"
EOS
}

if (-d "$source_root/.svn" && $svn ne "") {
	$svninfo{'vcs'} = 'svn';

	# svn infoを実行、出力をすべて取り込む
	if (!open(my $FD, "-|", "\"$svn\" info --xml $source_root 2>&1")) {
		# svn が実行できない
		print "$script_name: '$svn' can not execute\n";
	}
	else {
		# 出力をすべて取り込む
		my $text = do { local $/; <$FD> };
		close($FD);

		# xmlパーサがインストールされていない環境もあるので
		# パターンマッチで実装
		if ($text =~ /<commit([^>]+)>/) {
			my $commit = $1;
			if ($commit =~ /revision=\"(\d+)\"/) {
				$svninfo{'Revision'} = $1;
			}
		}
		if ($text =~ /<relative-url>(.+)<\/relative-url>/) {
			my $url = $1;
			my $name = $url;
			$name =~ s/^\^\/(.*)$/$1/; # "\/" を削除する
			$svninfo{'name'} = $name;
		}
	}
}
elsif((-d "$source_root/.git" || -f "$source_root/.git") && $git ne "") {
	$svninfo{'vcs'} = 'git';

	my $branch = `\"$git\" rev-parse --abbrev-ref HEAD`;
	if ($branch eq '') {
		# git が実行できない
		print "$script_name: \"$git\" can not execute\n";
	}
	else {
		$branch =~ s/[\r\n]$//g;
		$svninfo{'name'} = $branch;

		my $revision = `\"$git\" rev-parse --short HEAD`;
		$revision =~ s/[\r\n]$//g;
		$svninfo{'Revision'} = $revision;
	}
}
else {
	# do not use VCS
}

my $release = 0;
if ($tt_version_substr eq "") {
	$release = 1;
}
$svninfo{'release'} = $release;


if ($verbose != 0) {
	&dump_info(%svninfo);
}

my $same;

# output for source(C,C++) header
$same = 0;
my $out_header_tmp = $out_header . ".tmp";
write_info_header($out_header_tmp, %svninfo);
if (!$overwrite && &compare_file($out_header, $out_header_tmp) == 0) {
	# same
	unlink $out_header_tmp;
	$same = 1;
} else {
	#diff
	unlink $out_header;
	rename $out_header_tmp,  $out_header;
}
if ($verbose != 0) {
	printf("%s '$out_header'\n", $same == 1 ? "exists" : "update" );
}

# output for bat file
$same = 0;
my $out_bat_tmp = $out_bat . ".tmp";
write_info_bat($out_bat_tmp, %svninfo);
if (!$overwrite && &compare_file($out_bat, $out_bat_tmp) == 0) {
	# same
	unlink $out_bat_tmp;
	$same = 1;
} else {
	#diff
	unlink $out_bat;
	rename $out_bat_tmp,  $out_bat;
}
if ($verbose != 0) {
	printf("%s '$out_bat'\n", $same == 1 ? "exists" : "update" );
}

# output for cmake
if ($out_cmake ne "") {
	my $out_cmake_tmp = $out_cmake . ".tmp";
	&write_info_cmake($out_cmake_tmp, %svninfo);
	$same = 0;
	if (!$overwrite && &compare_file($out_cmake, $out_cmake_tmp) == 0) {
		# same
		unlink $out_cmake_tmp;
		$same = 1;
	} else {
		# diff
		unlink $out_cmake;
		rename $out_cmake_tmp,  $out_cmake;
	}
	if ($verbose != 0) {
		printf("%s '$out_cmake'\n", $same == 1 ? "exists" : "update" );
	}
}

# output for json
if ($out_json ne "") {
	my $out_json_tmp = $out_json . ".tmp";
	&write_info_json($out_json_tmp, %svninfo);
	$same = 0;
	if (!$overwrite && &compare_file($out_json, $out_json_tmp) == 0) {
		# same
		unlink $out_json_tmp;
		$same = 1;
	} else {
		# diff
		unlink $out_json;
		rename $out_json_tmp,  $out_json;
	}
	if ($verbose != 0) {
		printf("%s '$out_json'\n", $same == 1 ? "exists" : "update" );
	}
}

# output for InnoSetup
if ($out_isl ne "") {
	my $out_isl_tmp = $out_isl . ".tmp";
	&write_info_isl($out_isl_tmp, %svninfo);
	$same = 0;
	if (!$overwrite && &compare_file($out_isl, $out_isl_tmp) == 0) {
		# same
		unlink $out_isl_tmp;
		$same = 1;
	} else {
		# diff
		unlink $out_isl;
		rename $out_isl_tmp,  $out_isl;
	}
	if ($verbose != 0) {
		printf("%s '$out_isl'\n", $same == 1 ? "exists" : "update" );
	}
}
